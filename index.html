<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Advanced Gelbooru Viewer</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Pacifico&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-grad-start: #190021;
      --bg-grad-end: #2d0036;
      --header-grad-start: #2d0036;
      --header-grad-end: #ff2a68;
      --primary: #e75480;
      --primary-hover: #ff7eb9;
      --primary-shadow: #ff2a6899;
      --text: #fff;
      --text-muted: #ffb3d2;
      --input-bg: #1a001d;
      --thumb-bg: #1e1e1e;
      --thumb-shadow: #8f5fff66;
      --thumb-border-hover: #e75480;
      --modal-bg: rgba(30,0,50,0.97);
      --scanline-opacity: 0;
      --success-color: #218838;
      --error-color: #c82333;
    }
    body.light {
      --bg-grad-start: #fdf6ff;
      --bg-grad-end: #e8e6f3;
      --header-grad-start: #f8cdda;
      --header-grad-end: #a252a2;
      --primary: #b363a3;
      --primary-hover: #d382c3;
      --primary-shadow: #a252a266;
      --text: #2c2c2c;
      --text-muted: #a252a2;
      --input-bg: #fff;
      --thumb-bg: #fff;
      --thumb-shadow: #a252a233;
      --thumb-border-hover: #b363a3;
      --modal-bg: rgba(240, 230, 250, 0.97);
      --success-color: #218838;
      --error-color: #c82333;
    }
    body {
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      background: linear-gradient(120deg, var(--bg-grad-start) 0%, var(--bg-grad-end) 100%);
      color: var(--text);
      transition: background 0.4s, color 0.4s;
      min-height: 100vh;
      position: relative;
    }
    body::after { /* Scanline effect for easter egg */
      content: '';
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
      background-size: 100% 4px, 6px 100%;
      z-index: 9999;
      pointer-events: none;
      opacity: var(--scanline-opacity);
      transition: opacity 0.5s;
    }
    header {
      padding: 1rem;
      background: linear-gradient(90deg, var(--header-grad-start) 0%, var(--header-grad-end) 100%);
      border-bottom: 3px solid var(--primary);
      box-shadow: 0 2px 16px var(--primary-shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
      font-family: 'Playfair Display', serif;
      font-size: 1.2em;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    .stats {
      color: var(--primary-hover);
      font-size: 1.1em;
      font-family: 'Pacifico', cursive;
      text-shadow: 0 0 8px var(--primary-shadow);
      display: flex;
      align-items: center;
      gap: 0.5em;
    }
    .stats::before { content: "💋"; font-size: 1.2em; vertical-align: middle; }
    header input, header button, header select {
      padding: 0.5em; font-size: 1em; border: none; border-radius: 999px; margin: 0 0.2em;
    }
    header input {
      background: var(--input-bg);
      color: var(--text);
      border: 1.5px solid var(--primary);
      font-family: 'Segoe UI', sans-serif;
      transition: box-shadow 0.2s, background 0.4s, color 0.4s;
      box-shadow: 0 0 6px var(--primary-shadow);
    }
    header input:focus { box-shadow: 0 0 18px var(--primary-shadow); outline: none; }
    header button, header select {
      background: var(--primary); color: #fff; font-weight: bold;
      transition: background 0.2s, box-shadow 0.2s, transform 0.1s;
      box-shadow: 0 0 10px var(--primary-shadow); cursor: pointer;
    }
    header button:hover, header select:hover { background: var(--primary-hover); box-shadow: 0 0 30px var(--primary-shadow); transform: scale(1.08); }
    #toggleTheme {
      background: #111; color: #ff7eb9; border: 2px solid var(--primary); box-shadow: 0 0 8px var(--primary-shadow);
    }
    #toggleTheme:hover { background: var(--primary-hover); color: #111; box-shadow: 0 0 16px var(--primary); }
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 18px; padding: 1.5rem;
    }
    .thumb {
      position: relative; overflow: hidden; border-radius: 24px; cursor: pointer;
      transition: transform 0.25s, box-shadow 0.25s, border 0.2s;
      background: var(--thumb-bg);
      border: 2.5px solid transparent;
      box-shadow: 0 0 16px var(--thumb-shadow);
      will-change: transform;
    }
    .thumb:hover { transform: scale(1.06) rotate(-2deg); border-color: var(--thumb-border-hover); box-shadow: 0 0 40px var(--primary-shadow); z-index: 2; animation: shake 0.25s; }
    @keyframes shake {
      0%, 100% { transform: scale(1.06) rotate(-2deg); }
      50% { transform: scale(1.07) rotate(2deg); }
    }
    .thumb img {
      width: 100%; height: 220px; object-fit: cover; border-radius: 22px;
      filter: brightness(0.92) contrast(1.05); transition: filter 0.2s, transform 0.3s;
    }
    .thumb:hover img { filter: brightness(1.04) blur(1px) contrast(1.15); transform: scale(1.1); }
    .tags {
      position: absolute; bottom: 0; width: 100%;
      background: linear-gradient(0deg, var(--primary) 0%, #00000000 100%);
      color: #fff; font-size: 0.9em; padding: 12px 7px 7px 7px; box-sizing: border-box;
      border-radius: 0 0 22px 22px; letter-spacing: 0.05em;
      font-family: 'Pacifico', cursive; display: flex; align-items: center; gap: 0.5em;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .tags::before { content: "✨"; color: var(--text-muted); margin-right: 0.3em; }
    .tag-item { cursor: pointer; text-decoration: underline; margin-right: 0.3em; }
    #slideshow {
      position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
      background: var(--modal-bg); backdrop-filter: blur(8px);
      display: none; flex-direction: column; justify-content: center; align-items: center;
      z-index: 1000; animation: fadeIn 0.5s;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    #slideshow.show { display: flex; }
    #slideImg {
      max-width: 90vw; max-height: 80vh; border-radius: 18px;
      box-shadow: 0 0 36px var(--primary-shadow); border: 3px solid var(--primary);
      transition: opacity 0.3s; object-fit: contain;
    }
    #slideTags {
      color: var(--text-muted); margin-top: 1rem; max-width: 80vw;
      text-align: center; font-size: 1.1em; word-wrap: break-word;
      text-shadow: 0 0 8px var(--primary-shadow);
      font-family: 'Pacifico', cursive; letter-spacing: 0.05em;
      max-height: 5vh; overflow-y: auto;
    }
    .slideshow-controls { margin-top: 0.8rem; display: flex; gap: 1rem; }
    .slideshow-controls button {
      background: var(--primary); color: #fff; border: none; padding: 0.7rem 1.5rem;
      border-radius: 999px; font-size: 1.5rem; cursor: pointer;
      transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
      box-shadow: 0 0 12px var(--primary-shadow);
    }
    .slideshow-controls button:hover { background: var(--primary-hover); transform: scale(1.1); box-shadow: 0 0 28px var(--primary-shadow); }
    .slideshow-controls a { font-size: 1.5rem; padding: 0.7rem; line-height: 1; text-decoration: none; }
    
    .info { text-align: center; color: var(--primary-hover); margin: 1.2rem; font-size: 16px; font-family: 'Playfair Display', serif; text-shadow: 0 0 6px var(--primary-shadow); }
    
    .modal {
      display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.7); align-items: center; justify-content: center;
    }
    .modal.show { display: flex; animation: fadeIn 0.3s; }
    .modal-content {
      background: var(--modal-bg); color: var(--text); padding: 2rem; border-radius: 20px;
      border: 2.5px solid var(--primary); box-shadow: 0 0 32px var(--primary-shadow);
      max-width: 90vw; max-height: 90vh; overflow-y: auto;
    }
    .modal-content h2 { font-family: 'Playfair Display', serif; letter-spacing: 0.08em; color: var(--primary-hover); text-shadow: 0 0 6px var(--primary-shadow); margin-top: 0; }
    
    /* Confirmation Modal Specific Styles */
    #confirmationModal .modal-content {
      text-align: center;
      padding: 1.5rem;
    }
    #confirmationModal p {
      margin-bottom: 1.5rem;
      font-size: 1.1em;
    }
    #confirmationModal .button-group {
      display: flex;
      justify-content: center;
      gap: 1rem;
    }
    #confirmationModal .button-group button {
      padding: 0.8em 1.5em;
      border-radius: 999px;
      font-size: 1em;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    #confirmationModal #confirmYes {
      background: var(--error-color);
      color: white;
      border: 2px solid var(--error-color);
      box-shadow: 0 4px 10px rgba(200,35,51,0.4);
    }
    #confirmationModal #confirmYes:hover {
      background: #e73d4e;
      box-shadow: 0 4px 20px rgba(200,35,51,0.6);
      transform: translateY(-2px);
    }
    #confirmationModal #confirmNo {
      background: var(--primary);
      color: white;
      border: 2px solid var(--primary);
      box-shadow: 0 4px 10px var(--primary-shadow);
    }
    #confirmationModal #confirmNo:hover {
      background: var(--primary-hover);
      box-shadow: 0 4px 20px var(--primary-shadow);
      transform: translateY(-2px);
    }


    .suggestions {
      position: absolute; background: #333; color: #fff; border-radius: 0 0 5px 5px;
      z-index: 500; max-height: 160px; overflow-y: auto; width: 250px;
      left: 0; top: 100%; font-family: 'Segoe UI', sans-serif; font-size: 1em;
      box-shadow: 0 3px 12px #00000099;
    }
    .suggestion-item { padding: 0.5em; cursor: pointer; }
    .suggestion-item:hover, .suggestion-item.active { background: var(--primary-hover); color: #222; }
    
    footer { text-align: center; color: var(--primary-hover); font-family: 'Pacifico', cursive; font-size: 1.2em; margin: 2em 0 1em 0; text-shadow: 0 0 8px var(--primary); user-select: none; letter-spacing: 0.03em; }
    
    /* Utility & Advanced UI */
    #loader {
      display: flex; justify-content: center; padding: 2rem; width: 100%; grid-column: 1 / -1;
    }
    .spinner {
      border: 4px solid var(--primary-shadow); border-top-color: var(--primary-hover);
      border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #backToTop {
      position: fixed; bottom: 20px; right: 20px; z-index: 500;
      background: var(--primary); color: white; border: none; border-radius: 50%;
      width: 50px; height: 50px; font-size: 24px; cursor: pointer;
      display: none; align-items: center; justify-content: center;
      box-shadow: 0 2px 10px #00000066;
      transition: opacity 0.3s, transform 0.3s, background-color 0.3s;
    }
    #backToTop.show { display: flex; }
    #backToTop:hover { background-color: var(--primary-hover); transform: scale(1.1); }
    
    #notification-container {
        position: fixed; top: 80px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px;
    }
    .notification {
        background: var(--primary); color: white; padding: 15px; border-radius: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 1em;
        opacity: 0; transform: translateX(100%); animation: slideIn 0.5s forwards;
    }
    .notification.error { background: var(--error-color); }
    .notification.success { background: var(--success-color); }
    @keyframes slideIn { to { opacity: 1; transform: translateX(0); } }
    @keyframes slideOut { to { opacity: 0; transform: translateX(100%); } }
    
    @media (max-width:600px) {
      header { flex-direction: column; }
      .thumb img { height: 160px; }
      .modal-content { padding: 1em; }
    }
  </style>
</head>
<body>
  <header>
    <div style="display:flex; gap:0.5rem; flex-wrap:wrap; flex:1; position:relative;">
      <input id="searchInput" placeholder="Search (e.g., '1girl -long_hair')..." aria-label="Search tags" autocomplete="off" aria-autocomplete="list"/>
      <div id="suggestions" class="suggestions" role="listbox" aria-label="Suggested tags" style="display:none;"></div>
      <button id="searchBtn" aria-label="Search images by tags">🔎 Search</button>
      <select id="sortSelect" aria-label="Sort images">
        <option value="date">Sort by Date</option>
        <option value="popular">Sort by Popularity</option>
        <option value="random">Random</option>
      </select>
      <button id="favoritesBtn" aria-label="Show favorites">❤️ Favorites</button>
      <button id="clearFavs" aria-label="Clear all favorites">🗑️ Clear</button>
      <button id="toggleTheme" aria-label="Toggle dark and light mode">🌙/☀️</button>
    </div>
    <div class="stats" id="viewStats" aria-live="polite">Waifus seen: 0</div>
  </header>

  <main>
    <div class="gallery" id="gallery" role="list" aria-label="Image gallery"></div>
    <div id="loader" style="display:none;"><div class="spinner"></div></div>
    <div id="sentinel" aria-hidden="true" style="height: 1px;"></div>
  </main>

  <div class="info">Uses local storage for favorites and settings. Infinite scroll enabled.</div>

  <div id="slideshow" role="dialog" aria-modal="true" aria-label="Image slideshow" tabindex="-1">
    <img id="slideImg" alt="Slideshow image"/>
    <div id="slideTags"></div>
    <div class="slideshow-controls">
      <button id="prevSlide" aria-label="Previous image">⏪</button>
      <button id="nextSlide" aria-label="Next image">⏩</button>
      <button id="favoriteSlide" aria-label="Favorite this image">💖</button>
      <a id="downloadLink" href="#" download="image.jpg" class="slideshow-controls-button" aria-label="Download full image" title="Download">💾</a>
      <button id="closeSlideshow" aria-label="Close slideshow">❌</button>
    </div>
  </div>

  <div id="favoritesModal" class="modal" role="dialog" aria-modal="true" aria-label="Favorites">
    <div class="modal-content">
      <h2 id="modalTitle">Favorites</h2>
      <div id="modalBody" class="gallery"></div>
      <button id="closeModal" aria-label="Close modal">Close</button>
    </div>
  </div>
  
  <!-- Custom Confirmation Modal -->
  <div id="confirmationModal" class="modal" role="dialog" aria-modal="true" aria-label="Confirmation">
    <div class="modal-content">
      <h2 id="confirmTitle">Confirm Action</h2>
      <p id="confirmMessage">Are you sure you want to proceed?</p>
      <div class="button-group">
        <button id="confirmYes">Yes</button>
        <button id="confirmNo">No</button>
      </div>
    </div>
  </div>
  
  <div id="notification-container"></div>
  <button id="backToTop" title="Back to top">⬆️</button>
  
  <footer>
    Made with ❤️ for waifu lovers &mdash; <span style="color:var(--text);opacity:0.3;">ADVANCED EDITION</span>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {

      const app = {
        state: {
          page: 0,
          seen: 0,
          currentTags: '',
          images: [],
          currentSlideIndex: 0,
          isLoading: false,
          currentSort: 'date',
          favorites: [],
          konamiActivated: false,
          activeSuggestion: -1,
          confirmAction: null, // Stores the function to call on confirmation
        },
        elements: {
          gallery: document.getElementById('gallery'),
          slideImg: document.getElementById('slideImg'),
          slideTags: document.getElementById('slideTags'),
          stats: document.getElementById('viewStats'),
          slideshow: document.getElementById('slideshow'),
          sortSelect: document.getElementById('sortSelect'),
          searchInput: document.getElementById('searchInput'),
          suggestionsBox: document.getElementById('suggestions'),
          modal: document.getElementById('favoritesModal'),
          modalTitle: document.getElementById('modalTitle'),
          modalBody: document.getElementById('modalBody'),
          loader: document.getElementById('loader'),
          sentinel: document.getElementById('sentinel'),
          backToTop: document.getElementById('backToTop'),
          notificationContainer: document.getElementById('notification-container'),
          downloadLink: document.getElementById('downloadLink'),
          // New confirmation modal elements
          confirmationModal: document.getElementById('confirmationModal'),
          confirmTitle: document.getElementById('confirmTitle'),
          confirmMessage: document.getElementById('confirmMessage'),
          confirmYes: document.getElementById('confirmYes'),
          confirmNo: document.getElementById('confirmNo'),
        },
        init() {
          this.loadSettings();
          this.attachEventListeners();
          this.elements.stats.textContent = `Waifus seen: ${this.state.seen}`;
          this.search();
          this.initIntersectionObserver();
        },
        
        // --- Storage & Settings ---
        storage: {
          get: (key, fallback = null) => {
            try {
              const item = localStorage.getItem(key);
              return item ? JSON.parse(item) : fallback;
            } catch (e) { console.error('Failed to parse from localStorage', e); return fallback; }
          },
          set: (key, value) => {
            try { localStorage.setItem(key, JSON.stringify(value)); } 
            catch (e) { console.error('Failed to set localStorage item', e); }
          }
        },
        loadSettings() {
          const theme = this.storage.get('theme', 'dark');
          if (theme === 'light') document.body.classList.add('light');

          this.state.seen = this.storage.get('waifus_seen', 0);
          this.state.favorites = this.storage.get('favorites', []);
          this.state.currentSort = this.storage.get('sort_order', 'date');
          this.elements.sortSelect.value = this.state.currentSort;
          this.state.currentTags = this.storage.get('last_search', '');
          this.elements.searchInput.value = this.state.currentTags;
        },

        // --- API & Data Fetching ---
        api: {
          // Mock database for tag suggestions
          _mockTagsDb: ['1girl', 'solo', 'long_hair', 'breasts', 'blush', 'smile', 'looking_at_viewer', 'short_hair', 'blue_eyes', 'skirt', 'blonde_hair', 'open_mouth', 'thighhighs', 'ribbons', 'multiple_girls', 'dress', 'brown_hair', 'red_eyes', 'school_uniform', 'twintails', 'hair_ornament', 'hat', 'animal_ears', 'long_sleeves', 'shirt', 'bare_shoulders', 'catgirl', 'black_hair', 'bow', 'cleavage', 'gloves', 'very_long_hair', 'green_eyes', 'stockings', 'ponytail', 'white_hair', 'purple_eyes', 'pantyhose', 'navel', 'bikini', 'swimsuit', 'maid', 'hairband', 'fox_girl', 'jewelry', 'braids', 'ahoge', 'tail', 'barefoot', 'bangs', 'weapon', 'short_shorts', 'sidelocks', 'sword', 'zettai_ryouiki', 'food', 'animal_ear_fluff', 'gun', 'glasses', 'uniform', 'earrings', 'pink_hair', 'wings', 'horns', 'elf', 'yukata', 'geta'],
          
          // Fetches images from your local API endpoint or Vercel-hosted API
          fetchImages: async ({ tags, page, limit, sort }) => {
            await new Promise(res => setTimeout(res, 500)); // Simulate network latency
            
            // Use a relative path, which Vercel will correctly route to your serverless function
            // On local development, if you use a server like the one provided previously,
            // it will also correctly route this relative path.
            const apiUrl = `/api/images?tags=${encodeURIComponent(tags)}&page=${page}&limit=${limit}&sort=${sort}&_=${Date.now()}`;

            const res = await fetch(apiUrl);
            if (!res.ok) {
              const errorText = await res.text(); // Get error response text
              throw new Error(`Fetch failed: ${res.status} ${res.statusText} - ${errorText}`);
            }
            const data = await res.json();
            return Array.isArray(data.post) ? data.post : [];
          },

          // Fetches tag suggestions from the mock database
          fetchTagSuggestions: async (query) => {
            if (!query) return [];
            await new Promise(res => setTimeout(res, 100)); // Simulate network latency
            const qLower = query.toLowerCase();
            return app.api._mockTagsDb.filter(tag => tag.includes(qLower)).slice(0, 10);
          }
        },

        // Fetches and renders images based on current state
        async fetchAndRenderImages(append = false) {
          if (this.state.isLoading) return; // Prevent multiple simultaneous loads
          this.state.isLoading = true;
          this.elements.loader.style.display = 'flex'; // Show loader

          try {
            const posts = await this.api.fetchImages({
              tags: this.state.currentTags,
              page: this.state.page,
              limit: 20, // Number of images to fetch per page
              sort: this.state.currentSort
            });

            if (!append) {
              this.state.images = []; // Clear existing images for new search
              this.elements.gallery.innerHTML = ''; // Clear gallery
            }
            this.state.images.push(...posts); // Add new posts to state
            this.renderImages(posts); // Render new posts
            
            // Update seen count and save to storage
            this.state.seen += posts.length;
            this.elements.stats.textContent = `Waifus seen: ${this.state.seen}`;
            this.storage.set('waifus_seen', this.state.seen);
          } catch (e) {
            console.error(e);
            this.showNotification(`Error loading images: ${e.message}. Check Vercel logs or network tab.`, 'error');
          } finally {
            this.state.isLoading = false; // Reset loading state
            this.elements.loader.style.display = 'none'; // Hide loader
          }
        },

        // --- Rendering ---
        // Renders an array of image posts to the gallery
        renderImages(posts) {
          const frag = document.createDocumentFragment();
          posts.forEach((post, index) => {
            // Calculate global index for slideshow
            const globalIndex = this.state.images.length - posts.length + index;
            frag.appendChild(this.createThumbnail(post, globalIndex));
          });
          this.elements.gallery.appendChild(frag);
        },

        // Creates a single thumbnail element for an image post
        createThumbnail(post, index) {
          const div = document.createElement('div');
          div.className = 'thumb';
          div.tabIndex = 0; // Make thumbnail focusable
          div.role = 'listitem';
          div.setAttribute('aria-label', `Tags: ${post.tags}`);
          div.dataset.index = index; // Store index for slideshow

          const img = document.createElement('img');
          img.src = post.preview_url || post.sample_url || ''; // Use preview or sample URL
          img.alt = post.tags || 'Image';
          img.loading = "lazy"; // Lazy load images
          // Add onerror to handle broken image URLs gracefully
          img.onerror = function() {
              this.onerror=null; // Prevent infinite loop if fallback also fails
              this.src='https://placehold.co/220x220/800000/FFFFFF?text=Image+Error'; // Red placeholder with text
              this.alt='Image failed to load';
              this.style.filter = 'grayscale(100%)'; // Visual indicator of failure
          };
          
          const tagDiv = document.createElement('div');
          tagDiv.className = 'tags';
          this.renderClickableTags(post.tags, tagDiv, 4); // Show up to 4 tags

          div.append(img, tagDiv);
          return div;
        },

        // Renders clickable tags within a container
        renderClickableTags(tagString, container, limit = Infinity) {
          container.innerHTML = '';
          tagString.split(' ').slice(0, limit).forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.textContent = tag.replace(/_/g, ' '); // Replace underscores for readability
            tagSpan.className = 'tag-item';
            tagSpan.addEventListener('click', e => {
              e.stopPropagation(); // Prevent opening slideshow when clicking tag
              this.elements.searchInput.value = tag; // Set search input to clicked tag
              if(this.elements.slideshow.classList.contains('show')) this.hideSlideshow(); // Hide slideshow if open
              this.search(); // Perform new search
            });
            container.appendChild(tagSpan);
          });
        },
        
        // --- UI & Event Handlers ---
        attachEventListeners() {
          document.getElementById('searchBtn').addEventListener('click', () => this.search());
          this.elements.searchInput.addEventListener('keydown', e => {
            // Only trigger search on Enter if suggestions are not active
            if (e.key === 'Enter' && this.elements.suggestionsBox.style.display === 'none') {
              this.search();
            }
          });
          this.elements.sortSelect.addEventListener('change', () => this.handleSortChange());
          
          // Theme Toggle
          document.getElementById('toggleTheme').addEventListener('click', () => this.toggleTheme());

          // Favorites buttons
          document.getElementById('favoritesBtn').addEventListener('click', () => this.showFavorites());
          document.getElementById('clearFavs').addEventListener('click', () => {
            // Show confirmation modal before clearing favorites
            this.showConfirmation('Are you sure you want to clear ALL your waifus from your harem? This cannot be undone!', () => {
              this.clearFavoritesConfirmed();
            });
          });
          
          // Modals & Slideshow
          document.getElementById('closeModal').addEventListener('click', () => this.hideModal('favoritesModal'));
          this.elements.modal.addEventListener('click', e => e.target === this.elements.modal && this.hideModal('favoritesModal'));
          document.getElementById('closeSlideshow').addEventListener('click', () => this.hideSlideshow());
          
          // Confirmation modal buttons
          this.elements.confirmYes.addEventListener('click', () => this.handleConfirmation(true));
          this.elements.confirmNo.addEventListener('click', () => this.handleConfirmation(false));
          this.elements.confirmationModal.addEventListener('click', e => e.target === this.elements.confirmationModal && this.handleConfirmation(false));


          // Slideshow Controls
          document.getElementById('prevSlide').addEventListener('click', () => this.changeSlide(-1));
          document.getElementById('nextSlide').addEventListener('click', () => this.changeSlide(1));
          document.getElementById('favoriteSlide').addEventListener('click', () => this.toggleFavorite());

          // Gallery interaction (click and keyboard)
          this.elements.gallery.addEventListener('click', e => this.handleGalleryClick(e));
          this.elements.gallery.addEventListener('keydown', e => {
            if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('thumb')) {
              e.preventDefault(); // Prevent default scroll for spacebar
              this.handleGalleryClick(e);
            }
          });

          // Global Keydowns (for slideshow and modals)
          window.addEventListener('keydown', e => this.handleGlobalKeys(e));
          
          // Suggestions (input and keyboard navigation)
          this.elements.searchInput.addEventListener('input', e => this.handleSuggestionInput(e));
          this.elements.searchInput.addEventListener('keydown', e => this.handleSuggestionKeys(e));
          document.addEventListener('click', () => this.hideSuggestions()); // Hide suggestions when clicking outside

          // Back to top button
          window.addEventListener('scroll', () => this.toggleBackToTop());
          this.elements.backToTop.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

          // Konami Code Easter Egg
          const konami = [38,38,40,40,37,39,37,39,66,65]; // Up, Up, Down, Down, Left, Right, Left, Right, B, A
          let konamiIndex = 0;
          window.addEventListener('keydown', e => {
            if (e.keyCode === konami[konamiIndex++]) {
              if (konamiIndex === konami.length) {
                this.toggleKonamiMode();
                konamiIndex = 0; // Reset konami index
              }
            } else {
              konamiIndex = 0; // Reset if sequence is broken
            }
          });
        },
        
        // --- Actions ---
        // Initiates a new search
        search() {
          const query = this.elements.searchInput.value.trim();
          this.state.currentTags = query;
          this.storage.set('last_search', query); // Save last search query
          this.state.page = 0; // Reset page for new search
          this.hideSuggestions(); // Hide suggestions after search
          this.fetchAndRenderImages(false); // Fetch and render, not appending
        },

        // Loads more images (for infinite scroll)
        loadMoreImages() {
          this.state.page++; // Increment page number
          this.fetchAndRenderImages(true); // Fetch and append
        },

        // Handles sorting change
        handleSortChange() {
          this.state.currentSort = this.elements.sortSelect.value;
          this.storage.set('sort_order', this.state.currentSort); // Save sort order
          this.search(); // Re-search with new sort order
        },

        // Toggles between light and dark themes
        toggleTheme() {
          document.body.classList.toggle('light');
          const theme = document.body.classList.contains('light') ? 'light' : 'dark';
          this.storage.set('theme', theme); // Save theme preference
        },

        // Toggles Konami Mode (scanline effect)
        toggleKonamiMode() {
          this.state.konamiActivated = !this.state.konamiActivated;
          document.body.style.setProperty('--scanline-opacity', this.state.konamiActivated ? '0.2' : '0');
          this.showNotification(this.state.konamiActivated ? 'Konami Mode Activated! Retro vibes engaged.' : 'Konami Mode Deactivated. Back to normal.');
        },

        // --- Slideshow Logic ---
        // Displays the slideshow with a specific image
        showSlideshow(index) {
          this.state.currentSlideIndex = index;
          this.updateSlideContent();
          this.elements.slideshow.classList.add('show');
          this.elements.slideshow.focus(); // Focus slideshow for keyboard navigation
        },

        // Hides the slideshow
        hideSlideshow() {
          this.elements.slideshow.classList.remove('show');
          this.elements.slideImg.src = ''; // Clear image to save memory and prevent ghosting
        },

        // Updates the content of the current slide
        updateSlideContent() {
          const post = this.state.images[this.state.currentSlideIndex];
          if (!post) return;
          this.elements.slideImg.src = post.file_url || post.sample_url || '';
          this.elements.slideImg.alt = 'Tags: ' + post.tags;
          this.renderClickableTags(post.tags, this.elements.slideTags); // Render tags for current slide
          this.elements.downloadLink.href = post.file_url;
          this.elements.downloadLink.download = `gelbooru_${post.id}_${post.tags.split(' ')[0]}.jpg`;
          
          // Preload next and previous images for smoother transitions
          this.preloadImage(this.state.currentSlideIndex + 1);
          this.preloadImage(this.state.currentSlideIndex - 1);
        },

        // Changes the current slide in the slideshow
        changeSlide(direction) {
          const len = this.state.images.length;
          if (len === 0) return;
          this.state.currentSlideIndex = (this.state.currentSlideIndex + direction + len) % len;
          this.updateSlideContent();
        },

        // Preloads an image to cache it for faster display
        preloadImage(index) {
            const len = this.state.images.length;
            if (len === 0) return;
            const validIndex = (index + len) % len; // Ensure index wraps around
            const post = this.state.images[validIndex];
            if (post) {
                const img = new Image();
                img.src = post.file_url || post.sample_url; // Use high-res URL for preloading
            }
        },

        // Handles click events on gallery thumbnails
        handleGalleryClick(e) {
          const thumb = e.target.closest('.thumb');
          if (thumb && thumb.dataset.index) {
            this.showSlideshow(parseInt(thumb.dataset.index, 10));
          }
        },

        // --- Favorites Logic ---
        // Displays the favorites modal
        showFavorites() {
          this.elements.modalTitle.textContent = "Favorites";
          this.elements.modalBody.innerHTML = ''; // Clear previous favorites
          if (this.state.favorites.length === 0) {
            this.elements.modalBody.innerHTML = '<p style="padding:1em">Your harem is empty 🥺 Add some waifus!</p>';
          } else {
            const favsBackup = [...this.state.images]; // Backup current image list
            this.state.images = this.state.favorites; // Temporarily use favorites for slideshow logic
            this.state.favorites.forEach((post, index) => {
              const thumb = this.createThumbnail(post, index);
              thumb.addEventListener('click', () => {
                this.hideModal('favoritesModal');
                this.showSlideshow(index);
              });
              this.elements.modalBody.appendChild(thumb);
            });
            // Restore original image list after modal is closed
            this.elements.modal.addEventListener('transitionend', () => {
                this.state.images = favsBackup;
            }, { once: true });
          }
          this.elements.modal.classList.add('show');
        },

        // Toggles an image as favorite/unfavorite
        toggleFavorite() {
          const post = this.state.images[this.state.currentSlideIndex];
          if (!post) return;
          const favIndex = this.state.favorites.findIndex(fav => fav.id === post.id);
          if (favIndex >= 0) {
            this.state.favorites.splice(favIndex, 1); // Remove from favorites
            this.showNotification('Removed from favorites 🥺');
          } else {
            this.state.favorites.push(post); // Add to favorites
            this.showNotification('Added to your harem 💖', 'success');
          }
          this.storage.set('favorites', this.state.favorites); // Save updated favorites
        },

        // Clears all favorites after confirmation
        clearFavoritesConfirmed() {
          this.state.favorites = [];
          this.storage.set('favorites', []);
          this.showNotification('All favorites cleared 🗑️');
          // If the favorites modal is open, refresh its content
          if (this.elements.modal.classList.contains('show') && this.elements.modalTitle.textContent === "Favorites") {
            this.showFavorites();
          }
        },

        // --- Confirmation Modal Logic ---
        // Shows a custom confirmation modal
        showConfirmation(message, onConfirm) {
          this.elements.confirmMessage.textContent = message;
          this.state.confirmAction = onConfirm; // Store the callback
          this.elements.confirmationModal.classList.add('show');
        },

        // Handles the response from the confirmation modal
        handleConfirmation(confirmed) {
          this.elements.confirmationModal.classList.remove('show');
          if (confirmed && typeof this.state.confirmAction === 'function') {
            this.state.confirmAction(); // Execute the stored callback
          }
          this.state.confirmAction = null; // Clear the callback
        },

        // Hides a generic modal (favorites or confirmation)
        hideModal(modalId) {
          if (modalId === 'favoritesModal') {
            this.elements.modal.classList.remove('show');
          } else if (modalId === 'confirmationModal') {
            this.elements.confirmationModal.classList.remove('show');
          }
          // Reset the confirmAction if it's the confirmation modal being hidden
          if (modalId === 'confirmationModal') {
              this.state.confirmAction = null;
          }
        },

        // --- Suggestions Logic ---
        // Handles input for tag suggestions
        async handleSuggestionInput(e) {
            // Get the last word in the input as the query for suggestions
            const inputVal = e.target.value;
            const queryParts = inputVal.split(' ');
            const query = queryParts.pop(); // Get the last part of the query

            if (!query) {
                this.hideSuggestions();
                return;
            }
            const suggestions = await this.api.fetchTagSuggestions(query);
            if (suggestions.length > 0) {
                this.elements.suggestionsBox.innerHTML = '';
                suggestions.forEach((s, index) => {
                    const div = document.createElement('div');
                    div.className = 'suggestion-item';
                    div.textContent = s;
                    div.setAttribute('role', 'option');
                    div.setAttribute('id', `suggestion-${index}`); // Add ID for ARIA
                    div.addEventListener('mousedown', () => { // Use mousedown to prevent blur before click
                        // Replace the last part of the input with the selected suggestion
                        let terms = inputVal.split(' ');
                        terms[terms.length - 1] = s;
                        this.elements.searchInput.value = terms.join(' ') + ' '; // Add space for next tag
                        this.hideSuggestions();
                        this.elements.searchInput.focus(); // Keep focus on input
                    });
                    this.elements.suggestionsBox.appendChild(div);
                });
                this.elements.suggestionsBox.style.display = 'block';
                this.state.activeSuggestion = -1; // Reset active suggestion
                this.elements.searchInput.setAttribute('aria-expanded', 'true');
            } else {
                this.hideSuggestions();
            }
        },

        // Handles keyboard navigation for suggestions
        handleSuggestionKeys(e) {
          const items = this.elements.suggestionsBox.querySelectorAll('.suggestion-item');
          if (!items.length || this.elements.suggestionsBox.style.display === 'none') return;
          
          if (e.key === 'ArrowDown') {
            e.preventDefault(); // Prevent cursor movement in input
            this.state.activeSuggestion = (this.state.activeSuggestion + 1) % items.length;
          } else if (e.key === 'ArrowUp') {
            e.preventDefault(); // Prevent cursor movement in input
            this.state.activeSuggestion = (this.state.activeSuggestion - 1 + items.length) % items.length;
          } else if (e.key === 'Enter') {
            if (this.state.activeSuggestion > -1) {
              e.preventDefault(); // Prevent form submission
              items[this.state.activeSuggestion].dispatchEvent(new Event('mousedown', {bubbles: true}));
            } else {
              // If no suggestion is active, but Enter is pressed, perform search
              this.hideSuggestions();
              this.search();
            }
          } else if (e.key === 'Escape') {
            this.hideSuggestions();
          }

          // Update active class and aria-activedescendant
          items.forEach((item, idx) => item.classList.toggle('active', idx === this.state.activeSuggestion));
          if (this.state.activeSuggestion > -1) {
            this.elements.searchInput.setAttribute('aria-activedescendant', `suggestion-${this.state.activeSuggestion}`);
          } else {
            this.elements.searchInput.removeAttribute('aria-activedescendant');
          }
          if (this.state.activeSuggestion > -1) {
            items[this.state.activeSuggestion].scrollIntoView({ block: 'nearest' });
          }
        },

        // Hides the suggestion box
        hideSuggestions() {
          this.elements.suggestionsBox.style.display = 'none';
          this.state.activeSuggestion = -1;
          this.elements.searchInput.setAttribute('aria-expanded', 'false');
          this.elements.searchInput.removeAttribute('aria-activedescendant');
        },

        // --- Utilities ---
        // Handles global keyboard shortcuts for slideshow and modals
        handleGlobalKeys(e) {
          if (this.elements.modal.classList.contains('show') && e.key === 'Escape') this.hideModal('favoritesModal');
          if (this.elements.confirmationModal.classList.contains('show') && e.key === 'Escape') this.handleConfirmation(false); // Pressing Escape declines confirmation
          if (this.elements.slideshow.classList.contains('show')) {
            switch (e.key) {
              case 'Escape': this.hideSlideshow(); break;
              case 'ArrowRight': this.changeSlide(1); break;
              case 'ArrowLeft': this.changeSlide(-1); break;
              case 'f': this.toggleFavorite(); break; // 'f' for favorite
            }
          }
        },

        // Initializes the Intersection Observer for infinite scroll
        initIntersectionObserver() {
          const observer = new IntersectionObserver(entries => {
            if (entries[0].isIntersecting && !this.state.isLoading) {
              this.loadMoreImages();
            }
          }, { rootMargin: "200px" }); // Load when sentinel is 200px from viewport
          observer.observe(this.elements.sentinel);
        },

        // Shows a temporary notification message
        showNotification(message, type = 'info') {
          const notificationDiv = document.createElement('div');
          notificationDiv.className = `notification ${type}`;
          notificationDiv.textContent = message;
          this.elements.notificationContainer.appendChild(notificationDiv);

          setTimeout(() => {
            notificationDiv.style.animation = 'slideOut 0.5s forwards';
            notificationDiv.addEventListener('animationend', () => {
              notificationDiv.remove();
            }, { once: true });
          }, 3000); // Notification disappears after 3 seconds
        },

        // Toggles the visibility of the "Back to Top" button
        toggleBackToTop() {
          if (window.scrollY > 300) { // Show button if scrolled more than 300px
            this.elements.backToTop.classList.add('show');
          } else {
            this.elements.backToTop.classList.remove('show');
          }
        }
      };

      app.init(); // Initialize the application
    });
  </script>
</body>
</html>
